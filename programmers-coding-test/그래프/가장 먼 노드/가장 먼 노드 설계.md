1~6번의 노드가 있고,
[[3, 6], [4, 3], [3, 2], [1, 3], [1, 2], [2, 4], [5, 2]]

이차원 배열이 주어지는데,

각 노드 간의 최단거리 알고리즘이 있지 않을까

node 1이 다른 노드들의 최단거리를 모두 하나씩 구한다.
--
1번에서 7번을 찾아가려면,
[1, 2], [2, 3]
        [2, 4]
        [2, 5]
[1, 3], [3, 4]
        [3, 6]
이런 식으로 뎁스마다 경로가 많아질 것이다. 이 중에서 빨리 7번을 찾으면 반복문을 멈춘다. 
새 경로가 생길 때마다 경로를 담은 2차원 배열을 가진 Route instance를 만든다.

Route instance를 담는 배열이 있다.(routes)
그 배열을 돌리면서 7번까지 도달한게 있는지 확인한다.
도달하지 못했으면 반복하고, 도달했으면 해당 depth가 최단거리다.

routes에서 답이 나올때 까지 뎁스를 돌리는데, 
한번 뎁스를 돌릴 때마다 return값(도달한 노드)에 답이 있는지 확인한다.


--

그리고 그 거리의 값 이 가장 큰 녀석들의 수가 답이 된다.


---------------------------------------------------------
이거 dfs로 푸는 방식이 맞지 않을까?

stack을 써서 접근을 하는데 끝점에 도달한 경우에

추가한다.

stack에 node를 담았는데,
