1~6번의 노드가 있고,
[[3, 6], [4, 3], [3, 2], [1, 3], [1, 2], [2, 4], [5, 2]]

이차원 배열이 주어지는데,

각 노드 간의 최단거리 알고리즘이 있지 않을까

node 1이 다른 노드들의 최단거리를 모두 하나씩 구한다.
--
1번에서 7번을 찾아가려면,
[1, 2], [2, 3]
        [2, 4]
        [2, 5]
[1, 3], [3, 4]
        [3, 6]
이런 식으로 뎁스마다 경로가 많아질 것이다. 이 중에서 빨리 7번을 찾으면 반복문을 멈춘다. 
새 경로가 생길 때마다 경로를 담은 2차원 배열을 가진 Route instance를 만든다.

Route instance를 담는 배열이 있다.(routes)
그 배열을 돌리면서 7번까지 도달한게 있는지 확인한다.
도달하지 못했으면 반복하고, 도달했으면 해당 depth가 최단거리다.

routes에서 답이 나올때 까지 뎁스를 돌리는데, 
한번 뎁스를 돌릴 때마다 return값(도달한 노드)에 답이 있는지 확인한다.


--

그리고 그 거리의 값 이 가장 큰 녀석들의 수가 답이 된다.


---------------------------------------------------------
이거 dfs로 푸는 방식이 맞지 않을까?

stack을 써서 접근을 하는데 끝점에 도달한 경우에

추가한다.

stack에 node를 담았는데,


dfs()

node1부터 시작한다.

node1이 stack에 들어갈 때, depth를 기록한다.
node1이 pop되고, node1의 links들중 depth가 null인 linkedNode 모두 stack에 넣는다.
(stack에 linkedNode들이 들어갈때, depth를 기록한다.)

stack을 pop하고
poppedNode의 links중 depth가 null인 linkedNode만 모두 stack에 넣는다.
(stack에 linkedNode들이 들어갈때, depth를 기록한다.)


------------------------------

******************************
dfs가 아니라 bfs였다.
stack이 아니라 queue였고