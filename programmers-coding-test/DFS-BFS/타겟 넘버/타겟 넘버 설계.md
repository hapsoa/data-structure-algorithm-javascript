[1, 1, 1, 1, 1]로 숫자 3을 만들려면

4 - 1 이어야 한다.

[1, 2, 3, 4, 5] 3을 만들려면

(4+5) - (1+2+3)
(2+3+4) - (1+5)

경우의 수가 존재한다.

---

3을 만들기 위해서 배열의 첫번째 index부터 돌기 시작한다.
1은 3보다 작으니까 + 1
1 + 2 는 3과 같으니까 3
3 + 4 는 3보다 크니까 (3 - 4) -1
-1 + 5 는 3보다 크니까 4. 실패하네.

그렇다면,

배열의 index마다 시작을 돌려줘야 한다.
2 + 1 - 3 - 4 + 5 실패

어떻게 해야 3을 만드는데 모든 경우의 수를 알 수 있을까?

1과 -1, 2와 -2, 3과 -3, 4와 -4, 5와 -5 각각을 덧셈뺄셈을 모두 해서 원하는 값이 있을 때 numOfWays를 올려준다.

재귀 호출을 하면 가능할까? 가능하네. 재귀호출로 푼다.
"O(2^n)"

경우의 수는 2*2*2*2*2 = 32개. 2의 (배열의 element 수 승)

1, 2, 3, 4, 5
1, -2, 3, 4, 5
-1, 2, 3, 4, 5

1, -2, 3, 4, 5

for (let i = 0; i < 2; i++) {

}

if (a[0] === b[0]) {
if (a[1] === b[0]) {

} else if (a[1] === -b[1]){

}
} else if (a[0] === -b[0]) {

}
