각 지방 예산들 budgets [120, 110, 140, 150]
총 예산 M 485

총 덧셈을 해본다면, 520 인데, 여기서 485를 뺀다면
35인데, 35를 줄일 수 있어야 한다.

상한액이 몇이어야 35를 줄일 수 있을까?

내림차수로 sorting 한다.

가장 큰 수의 element들 lastMaximumIndex를 알아두고 다음,
budgets[0] ~ budgets[lastMaximumIndex] 까지 각 element를 1씩 뺀다.
1씩 뺄때마다 reducingBudget을 1씩 더한다.

가장 큰 수의 element들 lastMaximumIndex를 다시 체크한다.
budgets[0] ~ budgets[lastMaximumIndex] 까지 각 element를 1씩 뺀다.

reducingBudget이 reducingGoalBudget 이상이 된 경우에 그 때의 maximum 값(상한액)을 반환한다.


[150, 140, 120, 110]
[149, 140, 120, 110]
[148, 140, 120, 110]


속도에서 실패를 한다.

1씩 빼는 것이 아니라, 다음 단위까지 바로 빼는 것이 좋겠다.

<반복부분> lastMaximumIndex과 다음 index와의 값 차이를 계산하여, 
maximumIndex들의 값들을 모두 빼본다음에 그 값들의 합이 reducingGoalBudget(tempMoney) 보다 
작을 때, lastMaximumIndex= +몇 하고 tempMoney = tempMoney - budgets[lastMaximum] 후 반복한다.
클 때, 탈출한다.
[150, 140, 120, 110]
[140, 140, 120, 110] 35 - 10 이니 아직 양수니 다음
[120, 120, 120, 110] 120으로 모두 마출려니 25 - 20 - 20 하면 음수라 실패기 때문에,
25 <= 2 * x 려면은 x == 13
x = Math.ceil(25/2) // 13

maximum들을 모두 13씩 빼주면 되겠다.




시간초과가 또 되는 이유는 for문을 굳이 또 돌아서 그런듯 하다.
for문 또 돌리지 말고, 그냥 한번에 빼는게 낫지 않을까
[150, 140, 120, 110]

35가 차이가 나는데,

10, 
50(150-120, 140-120)
이 구조도 결국엔 for문 돈다.
