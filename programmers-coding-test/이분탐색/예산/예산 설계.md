각 지방 예산들 budgets [120, 110, 140, 150]
총 예산 M 485

총 덧셈을 해본다면, 520 인데, 여기서 485를 뺀다면
35인데, 35를 줄일 수 있어야 한다.

상한액이 몇이어야 35를 줄일 수 있을까?

내림차수로 sorting 한다.

가장 큰 수의 element들 lastMaximumIndex를 알아두고 다음,
budgets[0] ~ budgets[lastMaximumIndex] 까지 각 element를 1씩 뺀다.
1씩 뺄때마다 reducingBudget을 1씩 더한다.

가장 큰 수의 element들 lastMaximumIndex를 다시 체크한다.
budgets[0] ~ budgets[lastMaximumIndex] 까지 각 element를 1씩 뺀다.

reducingBudget이 reducingGoalBudget 이상이 된 경우에 그 때의 maximum 값(상한액)을 반환한다.


[150, 140, 120, 110]
[149, 140, 120, 110]
[148, 140, 120, 110]


속도에서 실패를 한다.

1씩 빼는 것이 아니라, 다음 단위까지 바로 빼는 것이 좋겠다.

<반복부분> lastMaximumIndex과 다음 index와의 값 차이를 계산하여, 
maximumIndex들의 값들을 모두 빼본다음에 그 값들의 합이 reducingGoalBudget(tempMoney) 보다 
작을 때, lastMaximumIndex= +몇 하고 tempMoney = tempMoney - budgets[lastMaximum] 후 반복한다.
클 때, 탈출한다.
[150, 140, 120, 110]
[140, 140, 120, 110] 35 - 10 이니 아직 양수니 다음
[120, 120, 120, 110] 120으로 모두 마출려니 25 - 20 - 20 하면 음수라 실패기 때문에,
25 <= 2 * x 려면은 x == 13
x = Math.ceil(25/2) // 13

maximum들을 모두 13씩 빼주면 되겠다.




시간초과가 또 되는 이유는 for문을 굳이 또 돌아서 그런듯 하다.
for문 또 돌리지 말고, 그냥 한번에 빼는게 낫지 않을까
[150, 140, 120, 110]

35가 차이가 나는데,

10, 
50(150-120, 140-120)
이 구조도 결국엔 for문 돈다.



----------------------
위의 전략이 실패했던 이유는 큰 수부터 하나씩 체크하기 때문에 O(n)이 기본적으로 시작된다.
그리고 마찬가지로 O(n)만큼[당장의 maximum으로 각 상한적용]이 다시 생기기 때문에 O(n제곱) 인듯하다.

하지만 이분탐색을 이용하게 되면, 중간 값부터 탐색해 들어가기 때문에 O(log n)이 기본적으로
시작이 되고, 하지만 다시 모든 budgets들에 대해 O(n)[당장의 maximum으로 각 상한적용]이 다시 생기기 때문에 
최종으로는 O(n logn)이 걸린다.

--

budgets를 sort() 한다.
[110, 120, 140, 150]
최소값(110)과 최대값(150)을 찾는다.

min 값과 max 값 사이의 middle 값((110+150)/2 = 130)을 상한선이라고 가정하고
상한선이 맞는지 체크한다.
[110, 120, 130, 130] 의 합은 490이다. 485보다 크므로

min = 110, max = middle(130) => middle = 115
[110, 115, 115, 115] 의 합은 445이다. 485보다 작으므로

min = middle(115) max = 130 => middle = 122(반내림)
[110, 120, 122, 122] 의 합은 474이다. 485보다 작으므로

min = middle(122) max = 130 => middle = 126
[110, 120, 126, 126] 의 합은 482이다. 485보다 작으므로

min = middle(126) max = 130 => middle = 128
[110, 120, 128, 128] 의 합은 486이다. 485보다 크므로

min = 126 max = 128(middle) => middle = 127
[110, 120, 127, 127] 의 합은 484이다. 485보다 작으므로

min = middle(127) max = 128 => middle = 127
min값과 max값의 차가 1밖에 차이가 나지 않으므로 이때의 middle값이 상한액이다.
// [110, 120, 126, 126] 의 합은 484이다. 485보다 작으므로

